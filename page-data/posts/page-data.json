{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"8571b886-3f14-5523-98e5-60f9060cef2a","excerpt":"모각코 3회차 계획 empty 모각코 3회차 결과 empty 모각코 3회차 계획 모각코 3회차 결과","fields":{"slug":"/mogakko-0115/"},"frontmatter":{"categories":"모각코","title":"동계 모각코 3회차","date":"January 15, 2022"}},"next":{"fields":{"slug":"/heroku-not-sleep/"}},"previous":null},{"node":{"id":"7fd530eb-4ee5-55e4-8d1f-d7dbe65350eb","excerpt":"Heroku 서버 Heroku는 백엔드 서버를 쉽게 만들수 있게 해주는 플랫폼이다. 이번 친구와 함께 하고 있는 설날 맞이 프로젝트를 위해 백엔드 서버는 Heroku를 사용하기로 하였다. Heroku 서버는 일정 시간 동안 접속이 없을 경우 서버가 멈춰버려서 다시 접근할 경우 시간이 더 걸리는 특징이 있다. 이를 방지하기 위해 할 수 있는 두 가지 방법을 소개하겠다. 1. node-cron 사용 node cron을 설치한다. 샘플 코드 위의 스크립트를 추가해주면 된다. 2. 모니터링 사이트 이용 UptimeRobot라는 사이트이다. 이 사이트는 내가 정해둔 시간마다 내 사이트로 요청을 보내주는 사이트이다.\n Friendly name에는 확인하고자 하는 사이트의 약칭을 작성한다. URL을 작성하고, Interval을 통해 시간을 설정할 수 있다. 설정 완료! 내가 한 설정 node-cron은 아무래도 http 요청을 보내서 그런 것인지 자꾸 다른 부분에서 오류가 발생해서 우선은 모니…","fields":{"slug":"/heroku-not-sleep/"},"frontmatter":{"categories":"프로젝트","title":"Heroku 항상 깨어있게 하기","date":"January 10, 2022"}},"next":{"fields":{"slug":"/mogakko-0108/"}},"previous":{"fields":{"slug":"/mogakko-0115/"}}},{"node":{"id":"d2ce7731-949c-5b9e-a124-6db38ae74cee","excerpt":"모각코 2회차 계획 empty 모각코 2회차 결과 empty 모각코 2회차 계획 모각코 2회차 결과","fields":{"slug":"/mogakko-0108/"},"frontmatter":{"categories":"모각코","title":"동계 모각코 2회차","date":"January 08, 2022"}},"next":{"fields":{"slug":"/mogakko-0101/"}},"previous":{"fields":{"slug":"/heroku-not-sleep/"}}},{"node":{"id":"46d86ff9-b8ef-575f-bb19-5b8a853c7946","excerpt":"모각코 1회차 계획 이번 방학에도 학교에서 진행하는 모각코에 참여하기로 하였다. 1회차의 목표는 새롭게 사용될 개발 블로그를 만드는 것이다. 정확히는 이미 만들어져있는 템플릿을 마음에 들게 바꾸는 것이긴하다. 모각코 1회차 결과 고민한 끝에\nhttps://dblepart99.github.io 모각코 1회차 계획 모각코 1회차 결과","fields":{"slug":"/mogakko-0101/"},"frontmatter":{"categories":"모각코","title":"동계 모각코 1회차","date":"January 01, 2022"}},"next":{"fields":{"slug":"/blog-start/"}},"previous":{"fields":{"slug":"/mogakko-0108/"}}},{"node":{"id":"d8256ea3-12c3-5774-837e-ec0eeb7b9699","excerpt":"블로그 변천사 개발 블로그는 18년도부터 썼던 것 같은데, 아직까지 제대로 정착하지 못했다. 처음에는 Tistory도 써보고, 전역하고 나서는 개발자라면.. ‘Git블로그 써야지!’ 라는 생각에 gh-pages를 이용한 블로그를 썼던 것 같다. 처음엔 Jekyll로 만들었지만, 여러 번의 테마 변경 그리고 맘에 들지 않아 Hexo를 이용한 블로그로 21년도 하반기 부터 옮겼었다. 새해 시작과 함께 좀 더 맘에 드는 테마를 찾아 나서기로 했다. 열심히 찾아본 결과 GitHub에서 zoomkoding님이 만드신 템플릿(?)을 찾을 수 있었다. 마음에 들어서 이 블로그를 이용하기로 마음 먹었다. 블로그 변천사","fields":{"slug":"/blog-start/"},"frontmatter":{"categories":"Blog","title":"새 블로그 시작!","date":"January 01, 2022"}},"next":{"fields":{"slug":"/Sort/"}},"previous":{"fields":{"slug":"/mogakko-0101/"}}},{"node":{"id":"a6193db5-6d63-515b-a279-5654c5447354","excerpt":"Selection Sort As you can see the word “Selection”. This algorithm always chooses the most minimum element in the array repeatedly from unsorted part and swap with the first element of unsorted part. 이름에서 볼 수 있듯 “선택”하는 정렬입니다. 이 알고리즘은 항상 배열이 정렬되지 않은 부분에서 최소의 원소를 정렬되지 않은 부분의 맨 앞으로 가져와 정렬합니다. 선택 정렬은 N-1번 만큼 가장 작은수를 찾아서 맨 앞으로 보내야합니다. (N번이 아닌 이유는 선택받지 못한 가장 마지막 원소는 가장 큰 원소이기 때문입니다.) 시간복잡도로 따지면 반복문이 이중 중첩이므로 O(N^2)입니다. Insertion Sort 삽입 정렬도 이름에서 볼 수 있듯이 매우 직관적입니다. 삽입 정렬은 원소를 특정한 위치에 적절히 삽입합니다.\n“적절히”라…","fields":{"slug":"/Sort/"},"frontmatter":{"categories":"알고리즘","title":"정렬","date":"September 01, 2021"}},"next":{"fields":{"slug":"/ubuntu-fcitx/"}},"previous":{"fields":{"slug":"/blog-start/"}}},{"node":{"id":"392205e6-0cff-5043-9030-980efb106746","excerpt":"1. fcitx 설치 terminal을 실행 후, 아래의 명령어를 순차적으로 입력해줍니다. 2. Language Support 실행 하단 Keyboard input method system -> fcitx 변경합니다. 3. fcitx 설정 상단에 생긴 키보드 버튼을 클릭 -> configure 좌측 하단의 +버튼을 클릭 Only show Current Language 체크 해제 후, hangul 선택 후 OK 한/영 키 변경 상단의 global config 탭 클릭 -> Trigger Input method -> shif+space버튼 누르기 개인 취향에 맞춰 설정하시면 됩니다. 1. fcitx 설치 2. Language Support 실행 3. fcitx 설정","fields":{"slug":"/ubuntu-fcitx/"},"frontmatter":{"categories":"Ubuntu","title":"Ubuntu 20.04 fcitx 한글 입력 설정","date":"July 29, 2021"}},"next":{"fields":{"slug":"/boj1475/"}},"previous":{"fields":{"slug":"/Sort/"}}},{"node":{"id":"27cfe591-8847-55d7-b2b6-fc3d43222745","excerpt":"백준 1475 방 번호 문제에 의하면 6과 9는 뒤집어서 이용할 수 있습니다. 그래서 모든 6과 9의 갯수를 더한 후, 2로 나누어 세트의 개수를 구할 수 있습니다. ex) 6669 => 6을 2장, 9를 2장으로 만들 수 있음.\n6과 9의 갯수를 더한 후, 2로 나누어줍니다. 만약 나머지가 있다면 한 세트를 더 뜯어야 한다는 뜻이므로 1을 더해줍니다. 주의 사항 0번 부터 9번까지의 숫자들이므로, 0 한 장만 입력받는 경우도 고려를 해야합니다. 백준 1475 방 번호","fields":{"slug":"/boj1475/"},"frontmatter":{"categories":"알고리즘","title":"백준-1475","date":"July 21, 2021"}},"next":{"fields":{"slug":"/boj10807/"}},"previous":{"fields":{"slug":"/ubuntu-fcitx/"}}},{"node":{"id":"a7481258-f45b-59b3-8630-ae6227f22fbb","excerpt":"백준 10807 개수 세기 입력받을 수 있는 숫자의 범위는 -100에서 100까지 총 201개입니다. 길이가 201인 int형 배열을 선언합니다.\nfill함수를 이용하여 배열 전체를 0으로 초기화해줍니다. 0은 -100에서 100까지의 수 중에서 101번째의 숫자이므로, 입력받은 수 + 100 의 index의 값을 +1을 해주며 입력받은 숫자의 갯수를 세줍니다.\n마지막으로 입력받은 숫자의 횟수를 출력합니다. 백준 10807 개수 세기","fields":{"slug":"/boj10807/"},"frontmatter":{"categories":"알고리즘","title":"백준 10807","date":"July 18, 2021"}},"next":null,"previous":{"fields":{"slug":"/boj1475/"}}}],"categories":["All","모각코","프로젝트","Blog","알고리즘","Ubuntu"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}